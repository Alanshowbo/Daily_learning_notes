# Linux C编程一站式学习
> http://akaedu.github.io/book/

## Part2 C语言本质

### 14 计算机中数的表示
+ 为什么计算机用2进制计数
  + 计算机是用数字电路搭成的，数字电路中只有1和0两种状态，或者可以说计算机只有两个手指，所 以对计算机来说二进制（Binary）是最自然的计数方式
+ 不同进制之间的换算
  + 二进制写起来太啰嗦了，所以通常将二 进制数分成每三位一组或者每四位一组，每组用一个数字表示。比如把(10110010)2从最低位开始 每三位分成一组，10、110、010，然后把每组写成一个十进制数字，就是(262)8，这样每一位数 字的取值范围是0~7，逢八进一，称为八进制（Octal）。类似地，把(10110010) 分成每四位一组，1011、0010，然后把每组写成一个数字，这个数的低位是2，高位已经大于9了，我们规定用 字母A~F表示10~15，这个数可以写成(B2)16，每一位数字的取值范围是0~F，逢十六进一，称为 十六进制（Hexadecimal）。
+ 整数的加减运算
  + Sign and Magnitude
    + 用8个bit表示正数和负数，把最高位规定为符号位（Sign Bit），0表示正1表示负，剩下的7位表示绝对值的大小，这称为Sign and Magnitude表示法。例如-1表示 成10000001，+1表示成00000001。这样用8个bit表示整数的取值范围是-27-1~27-1，即-127~127。
    + 如果两数符号位相同，就把它们的低7位相加，符号位不变。如果低7位相加时在最高位产生 进位，说明结果的绝对值大于127，超出7位所能表示的数值范围，这称为溢出 （Overflow）[24]，这时通常把计算机中的一个标志位置1表示当前运算产生了溢出
    + 如果两数符号位不同，首先比较它们的低7位谁大，然后用大数减小数，结果的符号位和大数相同
    + Sign and Magnitude效率低，0的表示不唯一
  + 1's Complement(二进制补码表示法)
    + 00001000-00000100 → 00001000+(-00000100) → 00001000+11111011 → 00000011进1 → 高 位进的1加到低位上去，结果为00000100 
    + 0的表示仍然不唯一，既可以表示成11111111也可以表示成00000000
  + 2's Complement
    + 2's Complement表示法规定：正数不变，负数先取反码再加1。如果8个bit采用2's Complement表 示法，负数的取值范围是从10000000到11111111（-128~-1），正数是 从00000000到01111111（0~127），也可以根据最高位判断一个数是正是负，并且0的表示是唯一的
+ 浮点数
  + 浮点数在计算机中的表示是基于科学计数法（Scientific Notation）的，我们知道32767这个数用科 学计数法可以写成3.2767×104，3.2767称为尾数（Mantissa，或者叫Significand），4称为指数 （Exponent）。浮点数在计算机中的表示与此类似，只不过基数（Radix）是2而不是10。

### 15 数据类型详解
#### 整型
+ C语言规定了signed和unsigned两个关键字，unsigned char型表示无符号 数，signed char型表示有符号数，为了可移植性就必须写明是signed还是unsigned；
+ 除了char型之外，整型还包括short int（或者简写为short）、int、long int（或者简写 为long）、long long int（或者简写为long long）等几种，这些类型都可以加 上signed或unsigned关键字表示有符号或无符号数
+ 除了char型在C标准中明确规定占一个字节之外，其它整型占几个字节都是Implementation Defined。通常的编译器实现遵守ILP32或LP64规范，如下表所示:
  |类型| ILP32（位数）| LP64（位数）|
  |:-----:|:-----:|:-----:|
  |char| 8 |8 |
  |short| 16| 16|
  |int| 32| 32|
  |long| 32| 64|
  |long long| 64| 64|
  |指针 |32| 64|
ILP32这个缩写的意思是int（I）、long（L）和指针（P）类型都占32位，通常32位计算机的C编 译器采用这种规范，x86平台的gcc也是如此。LP64是指long（L）和指针占64位，通常64位计算机 的C编译器采用这种规范。指针类型的长度总是和计算机的位数一致，平台是x86/Linux/gcc，一般遵循ILP32；
+ 八进制整数常量以0开头，后面的数字只能是0~7，例如022，因此十进制的整数常量就不能以0开头了，否则无法和八进制区分。十六进制整数常量以0x或0X开头；
+ 整数常量还可以在末尾加u或U表示“unsigned”，加l或L表示“long”，加ll或LL表示“long long”，例 如0x1234U，98765ULL等；
+ `long long i = 1234567890 * 1234567890;`编译时会有警告信息：`warning: integer overflow in expression`。1234567890是int型，两个int型相乘的表达式仍然是int型，而乘积已经超过int型 的取值范围了，因此提示计算结果溢出。如果改成`long long i = 1234567890LL * 1234567890;`， 其中一个常量是long long型，另一个常量也会先转换成long long型再做乘法运算，两数相乘的表 达式也是long long型，编译器就不会报警告了。








