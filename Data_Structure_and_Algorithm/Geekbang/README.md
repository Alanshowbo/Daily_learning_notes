# 数据结构与算法之美

## 03-复杂度分析（上）
### 时间复杂度
+ 时间复杂度分析
+ 常见时间复杂度
### 空间复杂度
+ 空间复杂度分析

## 04-复杂度分析（下）
+ 最好、最坏时间复杂度
+ 平均时间复杂度
+ 均摊时间复杂度

## 05-线性表-数组：为什么很多编程语言中数组都从0开始编号
+ 数组实现随机访问（寻址公式）
+ 低效的“插入”和“删除”
+ 警惕数组的越界访问（尤其对于C）
+ 容器（Java的ArrayList, C++的Vector）

## 06-线性表-链表（上）- 如何实现LRU缓存淘汰算法
+ 链表与数组在存储结构上的区别
+ 单链表：
  + 插入与删除的实现
+ 循环链表
+ 双向链表
  + 前驱节点、后序节点
  + 双向链表相比单链表：双向链表删除指定结点的优势，在指定结点前插入结点的优势
+ 双向循环链表
+ 链表相比于数组的性能特点
+ 空间换时间、时间换空间

## 07-线性表-链表（下）- 如何轻松写出正确的链表代码
+ 理解指针（C, C++）和引用(Java, Python)的含义
+ 警惕指针丢失和内存泄露
+ 利用哨兵简化实现难度
+ 重点留意边界条件处理
+ 画图辅助

## 08-线性表-栈：如何实现浏览器的前进和后退功能
+ 桟的先进后出、后进先出特性
+ 顺序栈、链式栈
+ 动态扩容顺序栈
+ 桟的应用
  + 桟在函数调用中的应用
  + 桟在表达式求值中的应用
  + 桟在括号匹配中的应用
+ 桟实现浏览器的前进和后退功能

## 09-线性表-队列：队列在线程池等有限资源池中的应用
+ 队列的先进先出特性
+ 顺序队列、链式队列
+ 循环队列
  + 避免数据搬移
  + 队列为空：head == tail, 队列已满：(tail+1)%n == head
+ 阻塞队列和并发队列
+ 队列常应用于任何有限的资源池中

## 10-递归-如何用三行代码找到“最终推荐人”
+ 递归需要满足的三个条件:
  + 一个问题的解可分为几个子问题的解
  + 此问题和分解之后的问题，除了数据规模不同，求解思路一致
  + 存在递归终止条件
+ 编写递归代码：写出递归公式和递归终止条件，再转化为代码即可
+ 递归存在的问题：
  + 警惕堆栈溢出：可以通过在代码中限制递归调用的最大深度的方式来解决这个问题，但这种做法一般只适用于最大深度比较小的情况
  + 重复计算：可以通过一个数据结构（比如散列表）来保存已经求解过的值，而后调用递归函数时先检查是否已计算过
+ 警惕脏数据：如果A的推荐人是B，B的推荐人是C，C的推荐人是A，就会发生死循环